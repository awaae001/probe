import (
	"database/sql"
	"discord-bot/models"
	"fmt"
	"log"
	"os"
	"strings"
	"sync"
	"time"
)

// MessageDB handles message database operations
type MessageDB struct {
	connections map[string]*sql.DB // guildID -> db connection
	mutex       sync.RWMutex
	config      models.MessageConfig
}

// NewMessageDB creates a new message database manager
func NewMessageDB(config models.MessageConfig) *MessageDB {
	return &MessageDB{
		connections: make(map[string]*sql.DB),
		config:      config,
	}
}

// CreateMessagesTable creates the messages table if it doesn't exist
func CreateMessagesTable(db *sql.DB) error {
	query := `
    CREATE TABLE IF NOT EXISTS messages (
        message_id INTEGER PRIMARY KEY,
        user_id INTEGER NOT NULL,
        guild_id INTEGER NOT NULL,
        channel_id INTEGER NOT NULL,
        timestamp INTEGER NOT NULL,
        message_content TEXT NOT NULL,
        attachments TEXT DEFAULT '',
        is_edited BOOLEAN DEFAULT FALSE
    );`

	if _, err := db.Exec(query); err != nil {
		return fmt.Errorf("failed to create messages table: %w", err)
	}

	// Create indexes for better query performance
	indexes := []string{
		"CREATE INDEX IF NOT EXISTS idx_user_timestamp ON messages(user_id, timestamp);",
		"CREATE INDEX IF NOT EXISTS idx_channel_timestamp ON messages(channel_id, timestamp);",
		"CREATE INDEX IF NOT EXISTS idx_guild_timestamp ON messages(guild_id, timestamp);",
	}

	for _, indexQuery := range indexes {
		if _, err := db.Exec(indexQuery); err != nil {
			log.Printf("Warning: failed to create index: %v", err)
		}
	}

	log.Println("Messages table and indexes created successfully")
	return nil
}

// CreateMessageDeletionsTable creates the message_deletions table if it doesn't exist
func CreateMessageDeletionsTable(db *sql.DB) error {
	query := `
    CREATE TABLE IF NOT EXISTS message_deletions (
        deletion_id INTEGER PRIMARY KEY AUTOINCREMENT,
        message_id INTEGER NOT NULL,
        guild_id INTEGER NOT NULL,
        channel_id INTEGER NOT NULL,
        deletion_timestamp INTEGER NOT NULL
    );`

	if _, err := db.Exec(query); err != nil {
		return fmt.Errorf("failed to create message_deletions table: %w", err)
	}

	// Create indexes for better query performance
	indexes := []string{
		"CREATE INDEX IF NOT EXISTS idx_message_deletions_message_id ON message_deletions(message_id);",
		"CREATE INDEX IF NOT EXISTS idx_message_deletions_guild_timestamp ON message_deletions(guild_id, deletion_timestamp);",
		"CREATE INDEX IF NOT EXISTS idx_message_deletions_channel_timestamp ON message_deletions(channel_id, deletion_timestamp);",
	}

	for _, indexQuery := range indexes {
		if _, err := db.Exec(indexQuery); err != nil {
			log.Printf("Warning: failed to create index: %v", err)
		}
	}

	log.Println("Message deletions table and indexes created successfully")
	return nil
}

// CreateMessageEditsTable creates the message_edits table if it doesn't exist
func CreateMessageEditsTable(db *sql.DB) error {
	query := `
    CREATE TABLE IF NOT EXISTS message_edits (
        edit_id INTEGER PRIMARY KEY AUTOINCREMENT,
        message_id INTEGER NOT NULL,
        guild_id INTEGER NOT NULL,
        channel_id INTEGER NOT NULL,
        original_content TEXT DEFAULT '',
        edited_content TEXT NOT NULL,
        original_attachments TEXT DEFAULT '',
        edited_attachments TEXT DEFAULT '',
        edit_timestamp INTEGER NOT NULL
    );`

	if _, err := db.Exec(query); err != nil {
		return fmt.Errorf("failed to create message_edits table: %w", err)
	}

	// Create indexes for better query performance
	indexes := []string{
		"CREATE INDEX IF NOT EXISTS idx_message_edits_message_id ON message_edits(message_id);",
		"CREATE INDEX IF NOT EXISTS idx_message_edits_guild_timestamp ON message_edits(guild_id, edit_timestamp);",
		"CREATE INDEX IF NOT EXISTS idx_message_edits_channel_timestamp ON message_edits(channel_id, edit_timestamp);",
	}

	for _, indexQuery := range indexes {
		if _, err := db.Exec(indexQuery); err != nil {
			log.Printf("Warning: failed to create index: %v", err)
		}
	}

	log.Println("Message edits table and indexes created successfully")
	return nil
}

// GetDBPath generates database path based on time type and current time
func (mdb *MessageDB) GetDBPath(guildID string) (string, error) {
	guildConfig, exists := mdb.config.MessageListener.Data[guildID]
	if !exists {
		return "", fmt.Errorf("guild %s not found in configuration", guildID)
	}

	basePath := guildConfig.DBPath
	timeType := guildConfig.TimeType

	now := time.Now()
	var timeSuffix string

	switch timeType {
	case "week":
		year, week := now.ISOWeek()
		// Debug logging to catch invalid dates
		if year < 2000 || week < 1 || week > 53 {
			log.Printf("Warning: Invalid ISO week calculation - year: %d, week: %d, time: %v", year, week, now)
			// Fallback to current time if calculation seems wrong
			now = time.Now()
			year, week = now.ISOWeek()
		}
		timeSuffix = fmt.Sprintf("%d-week-%d", year, week)
	case "month":
		timeSuffix = fmt.Sprintf("%d-month-%02d", now.Year(), now.Month())
	case "day":
		timeSuffix = fmt.Sprintf("%d-%02d-%02d", now.Year(), now.Month(), now.Day())
	default:
		timeSuffix = "default"
	}

	return strings.Replace(basePath, "$time_type", timeSuffix, 1), nil
}

// GetDBPathByTimestamp generates database path based on message timestamp
func (mdb *MessageDB) GetDBPathByTimestamp(guildID string, timestamp int64) (string, error) {
	guildConfig, exists := mdb.config.MessageListener.Data[guildID]
	if !exists {
		return "", fmt.Errorf("guild %s not found in configuration", guildID)
	}

	basePath := guildConfig.DBPath
	timeType := guildConfig.TimeType

	msgTime := time.Unix(timestamp, 0)
	var timeSuffix string

	switch timeType {
	case "week":
		year, week := msgTime.ISOWeek()
		// Debug logging to catch invalid dates
		if year < 2000 || week < 1 || week > 53 {
			log.Printf("Warning: Invalid ISO week calculation for timestamp %d - year: %d, week: %d, time: %v", timestamp, year, week, msgTime)
			// Fallback to current time if calculation seems wrong
			msgTime = time.Now()
			year, week = msgTime.ISOWeek()
		}
		timeSuffix = fmt.Sprintf("%d-week-%d", year, week)
	case "month":
		timeSuffix = fmt.Sprintf("%d-month-%02d", msgTime.Year(), msgTime.Month())
	case "day":
		timeSuffix = fmt.Sprintf("%d-%02d-%02d", msgTime.Year(), msgTime.Month(), msgTime.Day())
	default:
		timeSuffix = "default"
	}

	return strings.Replace(basePath, "$time_type", timeSuffix, 1), nil
}

// GetDB gets or creates a database connection for a guild
func (mdb *MessageDB) GetDB(guildID string) (*sql.DB, error) {
	mdb.mutex.RLock()
	if db, exists := mdb.connections[guildID]; exists {
		mdb.mutex.RUnlock()
		return db, nil
	}
	mdb.mutex.RUnlock()

	mdb.mutex.Lock()
	defer mdb.mutex.Unlock()

	// Double check after acquiring write lock
	if db, exists := mdb.connections[guildID]; exists {
		return db, nil
	}

	dbPath, err := mdb.GetDBPath(guildID)
	if err != nil {
		return nil, err
	}

	db, err := InitDB(dbPath)
	if err != nil {
		return nil, fmt.Errorf("failed to initialize message database for guild %s: %w", guildID, err)
	}

	if err := CreateMessagesTable(db); err != nil {
		db.Close()
		return nil, err
	}

	if err := CreateMessageDeletionsTable(db); err != nil {
		db.Close()
		return nil, err
	}

	if err := CreateMessageEditsTable(db); err != nil {
		db.Close()
		return nil, err
	}

	mdb.connections[guildID] = db
	log.Printf("Message database initialized for guild %s at %s", guildID, dbPath)
	return db, nil
}

// InsertMessage inserts a message record into the database
func (mdb *MessageDB) InsertMessage(msg models.Message) error {
	guildID := fmt.Sprintf("%d", msg.GuildID)
	db, err := mdb.GetDB(guildID)
	if err != nil {
		return err
	}

	query := `INSERT OR IGNORE INTO messages (message_id, user_id, guild_id, channel_id, timestamp, message_content, attachments, is_edited) 
              VALUES (?, ?, ?, ?, ?, ?, ?, ?)`

	stmt, err := db.Prepare(query)
	if err != nil {
		return fmt.Errorf("failed to prepare insert statement: %w", err)
	}
	defer stmt.Close()

	_, err = stmt.Exec(msg.MessageID, msg.UserID, msg.GuildID, msg.ChannelID, msg.Timestamp, msg.MessageContent, msg.Attachments, msg.IsEdited)
	if err != nil {
		return fmt.Errorf("failed to insert message %d: %w", msg.MessageID, err)
	}

	return nil
}

// GetChannelStats retrieves channel message statistics
func (mdb *MessageDB) GetChannelStats(guildID int64, from, to *time.Time) ([]models.ChannelStat, error) {
	guildIDStr := fmt.Sprintf("%d", guildID)
	db, err := mdb.GetDB(guildIDStr)
	if err != nil {
		return nil, err
	}

	query := `SELECT channel_id, COUNT(*) as message_count 
              FROM messages 
              WHERE guild_id = ?`
	args := []interface{}{guildID}

	if from != nil {
		query += " AND timestamp >= ?"
		args = append(args, from.Unix())
	}
	if to != nil {
		query += " AND timestamp < ?"
		args = append(args, to.Unix())
	}

	query += " GROUP BY channel_id ORDER BY message_count DESC"

	rows, err := db.Query(query, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to query channel stats: %w", err)
	}
	defer rows.Close()

	var stats []models.ChannelStat
	for rows.Next() {
		var stat models.ChannelStat
		if err := rows.Scan(&stat.ChannelID, &stat.MessageCount); err != nil {
			return nil, fmt.Errorf("failed to scan channel stat: %w", err)
		}
		stats = append(stats, stat)
	}

	return stats, nil
}

// GetUserStats retrieves user message statistics
func (mdb *MessageDB) GetUserStats(guildID int64, channelIDs []int64, from, to *time.Time) ([]models.UserStat, error) {
	guildIDStr := fmt.Sprintf("%d", guildID)
	db, err := mdb.GetDB(guildIDStr)
	if err != nil {
		return nil, err
	}

	query := `SELECT user_id, COUNT(*) as message_count 
              FROM messages 
              WHERE guild_id = ?`
	args := []interface{}{guildID}

	if len(channelIDs) > 0 {
		placeholders := strings.Repeat("?,", len(channelIDs))
		placeholders = placeholders[:len(placeholders)-1] // remove last comma
		query += " AND channel_id IN (" + placeholders + ")"
		for _, channelID := range channelIDs {
			args = append(args, channelID)
		}
	}

	if from != nil {
		query += " AND timestamp >= ?"
		args = append(args, from.Unix())
	}
	if to != nil {
		query += " AND timestamp < ?"
		args = append(args, to.Unix())
	}

	query += " GROUP BY user_id ORDER BY message_count DESC"

	rows, err := db.Query(query, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to query user stats: %w", err)
	}
	defer rows.Close()

	var stats []models.UserStat
	for rows.Next() {
		var stat models.UserStat
		if err := rows.Scan(&stat.UserID, &stat.MessageCount); err != nil {
			return nil, fmt.Errorf("failed to scan user stat: %w", err)
		}
		stats = append(stats, stat)
	}

	return stats, nil
}

// Close closes all database connections
func (mdb *MessageDB) Close() error {
	mdb.mutex.Lock()
	defer mdb.mutex.Unlock()

	var lastErr error
	for guildID, db := range mdb.connections {
		if err := db.Close(); err != nil {
			log.Printf("Error closing database for guild %s: %v", guildID, err)
			lastErr = err
		}
	}
	mdb.connections = make(map[string]*sql.DB)
	return lastErr
}

// GetMessageCount returns the total message count for a guild
func (mdb *MessageDB) GetMessageCount(guildID int64) (int64, error) {
	guildIDStr := fmt.Sprintf("%d", guildID)
	db, err := mdb.GetDB(guildIDStr)
	if err != nil {
		return 0, err
	}

	var count int64
	err = db.QueryRow("SELECT COUNT(*) FROM messages WHERE guild_id = ?", guildID).Scan(&count)
	if err != nil {
		return 0, fmt.Errorf("failed to get message count for guild %d: %w", guildID, err)
	}

	return count, nil
}

// extractTimestampFromDiscordID extracts timestamp from Discord snowflake ID
func extractTimestampFromDiscordID(id int64) int64 {
	// Discord snowflake format: (timestamp - 1420070400000) << 22 | worker_id << 17 | process_id << 12 | increment
	// Discord epoch: January 1, 2015, or 1420070400000 milliseconds since Unix epoch
	const discordEpoch = 1420070400000

	// Extract timestamp by shifting right 22 bits and adding Discord epoch
	timestampMs := (id >> 22) + discordEpoch
	return timestampMs / 1000 // Convert to Unix timestamp
}

// GetMessage retrieves a message by ID from the database
func (mdb *MessageDB) GetMessage(messageID int64) (*models.Message, error) {
	// Extract timestamp from Discord ID to determine which database to check
	timestamp := extractTimestampFromDiscordID(messageID)

	// Get all guild configurations to search across guilds
	for guildID := range mdb.config.MessageListener.Data {
		// Get database path based on the extracted timestamp
		dbPath, err := mdb.GetDBPathByTimestamp(guildID, timestamp)
		if err != nil {
			log.Printf("Failed to get DB path for guild %s and timestamp %d: %v", guildID, timestamp, err)
			continue
		}

		// Check if database file exists before trying to open it
		if _, err := os.Stat(dbPath); os.IsNotExist(err) {
			continue // Skip this guild if database doesn't exist
		}

		// Open the specific database for this timestamp (read-only)
		db, err := sql.Open("sqlite3", dbPath+"?mode=ro")
		if err != nil {
			continue // Skip this guild if we can't open the database
		}
		defer db.Close()

		query := `SELECT message_id, user_id, guild_id, channel_id, timestamp, message_content, attachments, is_edited 
		          FROM messages WHERE message_id = ?`

		var msg models.Message
		err = db.QueryRow(query, messageID).Scan(
			&msg.MessageID, &msg.UserID, &msg.GuildID, &msg.ChannelID,
			&msg.Timestamp, &msg.MessageContent, &msg.Attachments, &msg.IsEdited,
		)

		if err == nil {
			return &msg, nil // Found the message
		}

		if err != sql.ErrNoRows {
			log.Printf("Error querying message %d in guild %s database %s: %v", messageID, guildID, dbPath, err)
		}
	}

	// Message not found in any database
	return nil, fmt.Errorf("message %d not found in any database", messageID)
}

// InsertMessageDeletion records a message deletion event
func (mdb *MessageDB) InsertMessageDeletion(deletion models.MessageDeletion) error {
	guildIDStr := fmt.Sprintf("%d", deletion.GuildID)
	db, err := mdb.GetDB(guildIDStr)
	if err != nil {
		return fmt.Errorf("failed to get database connection: %w", err)
	}

	// Insert the deletion record
	query := `INSERT INTO message_deletions (message_id, guild_id, channel_id, deletion_timestamp) 
              VALUES (?, ?, ?, ?)`

	stmt, err := db.Prepare(query)
	if err != nil {
		return fmt.Errorf("failed to prepare deletion insert statement: %w", err)
	}
	defer stmt.Close()

	_, err = stmt.Exec(deletion.MessageID, deletion.GuildID, deletion.ChannelID, deletion.DeletionTimestamp)
	if err != nil {
		return fmt.Errorf("failed to insert message deletion %d: %w", deletion.MessageID, err)
	}

	log.Printf("Message deletion recorded: Guild %d, Message %d", deletion.GuildID, deletion.MessageID)
	return nil
}

// InsertMessageEdit records a message edit event
func (mdb *MessageDB) InsertMessageEdit(edit models.MessageEdit) error {
	guildIDStr := fmt.Sprintf("%d", edit.GuildID)
	db, err := mdb.GetDB(guildIDStr)
	if err != nil {
		return fmt.Errorf("failed to get database connection: %w", err)
	}

	// Insert the edit record
	query := `INSERT INTO message_edits (message_id, guild_id, channel_id, original_content, edited_content, original_attachments, edited_attachments, edit_timestamp) 
              VALUES (?, ?, ?, ?, ?, ?, ?, ?)`

	stmt, err := db.Prepare(query)
	if err != nil {
		return fmt.Errorf("failed to prepare edit insert statement: %w", err)
	}
	defer stmt.Close()

	_, err = stmt.Exec(edit.MessageID, edit.GuildID, edit.ChannelID, edit.OriginalContent, edit.EditedContent, edit.OriginalAttachments, edit.EditedAttachments, edit.EditTimestamp)
	if err != nil {
		return fmt.Errorf("failed to insert message edit %d: %w", edit.MessageID, err)
	}

	log.Printf("Message edit recorded: Guild %d, Message %d", edit.GuildID, edit.MessageID)
	return nil
}